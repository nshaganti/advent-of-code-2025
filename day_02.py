import sys
from pathlib import Path

# =============================================================================
#  Advent of Code 2025 - Day 2
#  Problem Link: https://adventofcode.com/2025/day/2
# =============================================================================

def parse_input(raw_data: str) -> list[tuple[int, int]]:
    """
    Parses a comma-separated string of ranges into tuples.
    Handles newlines and whitespace gracefully.
    """
    cleaned = []
    # Remove newlines to handle multi-line CSV strings
    # Split by comma and filter out empty strings
    tokens = [t.strip() for t in raw_data.replace('\n', '').split(',') if t.strip()]
    
    for token in tokens:
        if '-' in token:
            start, end = token.split('-')
            cleaned.append((int(start), int(end)))
    return cleaned

def part_1(ranges: list[tuple[int, int]]) -> int:
    """
    Sums IDs where the first half equals the second half (e.g., 1212, 55).
    
    Logic:
        We mathematically construct numbers of form XX (len 2), XXXX (len 4), etc.
        For length 4, we iterate seeds 10-99. 
        Candidate = seed * 101 (e.g., 12 * 101 = 1212).
        
    Complexity:
        Time: O(10^(D/2)) where D is the number of digits in the max ID.
              This is extremely fast compared to iterating the ranges.
        Space: O(1)
    """
    valid_sum = 0
    if not ranges:
        return 0
        
    global_min = min(r[0] for r in ranges)
    global_max = max(r[1] for r in ranges)
    
    # We only care about numbers with even number of digits
    # Max half-length is half the digits of the global max
    max_digits = len(str(global_max))
    max_half_len = max_digits // 2
    
    for half_len in range(1, max_half_len + 1):
        start_seed = 10**(half_len - 1)
        end_seed = 10**half_len
        
        # Multiplier to duplicate the seed (e.g., 101 for 2 digits, 10001 for 4)
        multiplier = (10**half_len) + 1
        
        for seed in range(start_seed, end_seed):
            candidate = seed * multiplier
            
            # --- Optimization Bounds ---
            if candidate > global_max:
                break 
            if candidate < global_min:
                continue
            # ---------------------------
            
            # Check if candidate falls within ANY user range
            for start, end in ranges:
                if start <= candidate <= end:
                    valid_sum += candidate
                    break 
                    
    return valid_sum

def part_2(ranges: list[tuple[int, int]]) -> int:
    """
    Sums IDs formed by repeating a substring (len >= 2).
    Examples: 121212 (12 repeated 3x), 5555 (5 repeated 4x).
    
    Logic:
        Iterate through possible total lengths and chunk lengths.
        Construct candidates via string repetition and check ranges.
        Uses a Set to avoid double counting numbers like '1111' 
        (generated by '1'x4 and '11'x2).

    Complexity:
        Time: O(10^(D/2) * K) where K is number of factors. Very efficient.
        Space: O(N) where N is number of valid matches found (to store in Set).
    """
    found_numbers = set()
    if not ranges:
        return 0
        
    global_min = min(r[0] for r in ranges)
    global_max = max(r[1] for r in ranges)
    max_digits = len(str(global_max))
    
    # Loop 1: Total length of the final number
    for total_len in range(2, max_digits + 1):
        
        # Loop 2: Length of the repeating chunk (must be at least 1)
        # A chunk can be at most half the total length to repeat at least twice
        for chunk_len in range(1, (total_len // 2) + 1):
            
            if total_len % chunk_len == 0:
                repeats = total_len // chunk_len
                
                start_seed = 10**(chunk_len - 1)
                end_seed = 10**chunk_len
                
                for seed in range(start_seed, end_seed):
                    # Construct candidate (String manip is cleaner here than log10 math)
                    candidate = int(str(seed) * repeats)
                    
                    if candidate > global_max:
                        break
                    if candidate < global_min:
                        continue
                        
                    # Check specific ranges
                    for start, end in ranges:
                        if start <= candidate <= end:
                            found_numbers.add(candidate)
                            break 

    return sum(found_numbers)

# =============================================================================
#  Unit Tests
# =============================================================================

def run_tests():
    """Runs tests on the sample input provided."""
    print("Running tests...", end=" ")
    
    sample_input = """
11-22,95-115,998-1012,1188511880-1188511890,222220-222224,
1698522-1698528,446443-446449,38593856-38593862,565653-565659,
824824821-824824827,2121212118-2121212124
"""
    parsed_data = parse_input(sample_input)
    
    # Test Part 1
    p1_expected = 1227775554
    p1_result = part_1(parsed_data)
    assert p1_result == p1_expected, f"Part 1 Failed: Expected {p1_expected}, got {p1_result}"
    
    # Test Part 2
    p2_expected = 4174379265
    p2_result = part_2(parsed_data)
    assert p2_result == p2_expected, f"Part 2 Failed: Expected {p2_expected}, got {p2_result}"
    
    print("ALL TESTS PASSED. ✅\n")

# =============================================================================
#  Main Execution
# =============================================================================

if __name__ == "__main__":
    # 1. Run Tests
    run_tests()
    
    # 2. Locate input file
    input_file = Path(__file__).parent / "inputs" / "day_02.txt"
    
    if not input_file.exists():
        print(f"⚠️  Input file not found at: {input_file}")
    else:
        # 3. Solve for real input
        raw_data = input_file.read_text()
        data = parse_input(raw_data)
        
        print(f"--- Day 2 Solution ---")
        print(f"Part 1: {part_1(data)}")
        print(f"Part 2: {part_2(data)}")